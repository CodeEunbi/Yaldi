# API 연동 규격서 구성 원칙

## 🎯 핵심 구성 방향

이 API 연동 규격서는 다음 **6가지 핵심 원칙**을 중심으로 구성되었습니다.

---

## 1. 엔터프라이즈급 표준 준수 🏢

### 포함된 표준
- **SLA/SLO**: 99.9% 가용성, p95 < 300ms 응답시간 명시
- **Rate Limiting**: 토큰 버킷 알고리즘, 엔드포인트별 정책
- **Audit Log**: 모든 API 호출 및 데이터 변경 기록 (90일 보관)
- **Webhook**: 이벤트 기반 아키텍처, HMAC 서명 검증
- **Batch API**: 최대 100개 요청 배치 처리, 의존성 지원
- **API Versioning**: URI 기반, Deprecation 3단계 프로세스

### 왜 중요한가?
> 단순한 CRUD API가 아닌, **프로덕션 환경에서 실제로 운영 가능한** API 명세를 제공합니다. 대규모 트래픽, 장애 상황, 버전 관리 등 실무에서 마주치는 문제들을 고려했습니다.

---

## 2. 보안 우선 설계 🔐

### 3-Layer 보안 아키텍처
1. **보안 및 통신** (03): HTTPS/TLS, WebSocket/SSE 암호화
2. **보안 및 인증** (04): JWT, OAuth 2.0, OIDC, RBAC
3. **보안 코딩** (05): CORS, Security Headers, Input Validation

### 세부 보안 요소
- **인증**: JWT RS256 (비대칭키), OAuth 2.0 + PKCE
- **권한**: RBAC (Owner/Editor/Viewer), Permission 체계
- **암호화**: TLS 1.3, AES-256, bcrypt (cost 12)
- **방어**: XSS, CSRF, SQL Injection, Path Traversal 대응
- **모니터링**: Audit Log (90일), Activity Log (30일)

### 왜 중요한가?
> 현대 웹 서비스는 **보안이 선택이 아닌 필수**입니다. GDPR, 개인정보보호법 등 법적 요구사항도 고려하여, 금융권/공공기관에서도 사용 가능한 수준의 보안 설계를 적용했습니다.

---

## 3. RESTful 아키텍처 완성도 🎨

### Richardson 성숙도 모델 Level 3 달성
- **Level 0**: HTTP 프로토콜 사용 ✅
- **Level 1**: 리소스 개념 도입 ✅
- **Level 2**: HTTP 메소드/상태 코드 적절히 사용 ✅
- **Level 3**: HATEOAS 구현 ✅

### RESTful 고급 기법
- **HATEOAS**: `_links` 필드로 다음 가능한 액션 제공
- **ETag 캐싱**: 304 Not Modified로 대역폭 절약
- **낙관적 잠금**: If-Match 헤더로 동시 수정 충돌 방지
- **멱등성**: POST 제외 모든 메소드 멱등성 보장
- **Content Negotiation**: Accept 헤더로 응답 형식 선택

### 왜 중요한가?
> **단순한 JSON API**를 넘어서, **진정한 RESTful API**를 설계했습니다. 클라이언트가 서버의 상태 변화를 자연스럽게 따라갈 수 있고, 캐싱을 통해 성능을 최적화할 수 있습니다.

---

## 4. 개발자 경험(DX) 최적화 👨‍💻

### 문서화 전략
- **06_API 레퍼런스**: 108개 API, 각각 예제 요청/응답 포함
- **10_예제**: JavaScript, Python, cURL 등 다양한 언어 예제
- **11_용어 설명**: 43개 기술 용어 사전 (JWT, OAuth, HATEOAS 등)
- **README.md**: 전체 문서 가이드, 빠른 시작 방법

### OpenAPI 3.0 호환
- Swagger UI로 자동 문서 생성 가능
- Postman Collection 자동 생성 가능
- TypeScript/Java 클라이언트 SDK 자동 생성 가능

### 상세한 에러 메시지
```json
{
  "code": "ERD_004",
  "type": "CircularReferenceError",
  "message": "순환 참조가 발생했습니다",
  "field": "relations",
  "details": { "cycle": [...] }
}
```

### 왜 중요한가?
> **좋은 API는 문서가 필요 없는 API**라는 말이 있지만, 실제로는 **상세하고 명확한 문서**가 개발 생산성을 크게 높입니다. 프론트엔드 개발자가 백엔드 개발자에게 질문하는 시간을 줄이는 것이 목표입니다.

---

## 5. 클라우드 네이티브 운영 ☁️

### Kubernetes 친화적 설계
- **Health Check**: Liveness/Readiness Probe
- **Metrics**: Prometheus 형식 메트릭 노출 (`/api/v1/metrics`)
- **Logging**: 구조화된 JSON 로그, ELK Stack 연동
- **Distributed Tracing**: OpenTelemetry, Jaeger 지원

### Microservice 전환 준비
- **API Gateway** 패턴 고려
- **Service Discovery** 개념 포함
- **Circuit Breaker** 장애 전파 방지
- **Saga Pattern** 분산 트랜잭션

### 모니터링 & SLO
- **성능 지표**: p50 < 100ms, p95 < 300ms, p99 < 1s
- **가용성**: 99.9% uptime (월 43분 다운타임)
- **에러율**: < 0.1%
- **Status Page**: https://status.yaldi.io

### 왜 중요한가?
> 현대 애플리케이션은 **단순히 작동하는 것**을 넘어, **관측 가능하고(Observable), 확장 가능하고(Scalable), 복원력이 있어야(Resilient)** 합니다. Monolith에서 Microservice로 전환할 때도 원활하게 마이그레이션할 수 있도록 설계했습니다.

---

## 6. 실무 적용 가능성 💼

### 실제 구현 가능한 명세
- **Spring Boot 3.x** 기준 구체적인 구현 방법
- **React 18.x** 프론트엔드 연동 고려
- **OAuth 2.0** Redirect URI, Callback 처리
- **WebSocket/SSE** 실시간 협업 구현 방법

### 검증된 기술 스택
```
Backend:  Spring Boot 3.x (Java 17+) - Port 8080
Frontend: React 18.x - Port 3000
Database: PostgreSQL / MySQL
Cache:    Redis (실시간 협업, Rate Limiting)
Storage:  AWS S3 (파일 저장)
```

### 단계별 구현 가이드
1. **개요** (01): 프로젝트 이해
2. **시작하기** (02): 로컬 환경 설정
3. **보안** (03-05): 인증/인가 구현
4. **API** (06): 엔드포인트 구현
5. **운영** (14): Health Check, Metrics 추가

### 왜 중요한가?
> **이론적으로만 완벽한 명세**는 의미가 없습니다. 실제로 **Spring Boot로 구현 가능하고, React에서 호출 가능한** 구체적인 명세를 제공합니다. "이걸 어떻게 구현하지?"라는 고민을 줄이는 것이 목표입니다.

---

## 📊 구성 통계

### 문서 규모
- **총 파일**: 15개 섹션 + README
- **총 행수**: 271행 (헤더 제외)
- **API 엔드포인트**: 108개
- **용어 정의**: 43개
- **에러 코드**: 14개 HTTP 상태 + 커스텀 코드 체계

### 보안 비중
- **보안 관련 섹션**: 3개 (03, 04, 05) - 38행
- **전체 대비 비중**: 14%
- **메시지**: "보안은 나중에 추가하는 것이 아닌, 처음부터 설계하는 것"

### API 설계 표준
- **엔터프라이즈 표준**: 12가지 (에러 코드, Pagination, Webhook, Rate Limiting 등)
- **RESTful 고급 기법**: 3가지 (HATEOAS, ETag, Optimistic Locking)
- **메시지**: "단순한 CRUD를 넘어선, 성숙한 API"

---

## 🎓 학습 목적 vs 실무 활용

### 학습 관점 📚
이 규격서는 다음을 학습할 수 있습니다:
- ✅ RESTful API 설계 베스트 프랙티스
- ✅ OAuth 2.0, JWT, RBAC 등 인증/인가 표준
- ✅ HATEOAS, ETag 등 HTTP 고급 기법
- ✅ Microservice 아키텍처 패턴
- ✅ 클라우드 네이티브 운영 방법

### 실무 관점 💼
이 규격서는 다음에 바로 활용 가능합니다:
- ✅ Spring Boot 프로젝트 API 명세로 사용
- ✅ 프론트엔드-백엔드 협업 문서로 사용
- ✅ OpenAPI 3.0 스펙으로 변환
- ✅ Postman Collection 자동 생성
- ✅ 클라이언트 SDK 자동 생성

---

## 🔍 차별화 포인트

### 다른 API 문서와의 차이점

| 항목 | 일반적인 API 문서 | Yaldi API 규격서 |
|------|------------------|------------------|
| **엔드포인트** | URL, Method만 명시 | 예제 요청/응답 포함 |
| **에러 처리** | HTTP 상태 코드만 | 커스텀 에러 코드 체계 |
| **보안** | 인증 방법만 명시 | 3-Layer 보안 아키텍처 |
| **확장성** | 언급 없음 | Microservice 전환 계획 |
| **운영** | 언급 없음 | Health Check, SLA/SLO |
| **용어 설명** | 없음 | 43개 기술 용어 사전 |
| **실무 연동** | 이론적 | 포트, Redirect URI까지 명시 |

---

## 💡 핵심 메시지

> "단순히 작동하는 API를 넘어서,  
> **보안이 강화되고, 확장 가능하며, 운영 가능한**  
> 엔터프라이즈급 API를 설계하는 방법"

이 규격서는 **Cloud 웹 서비스 기술 이해도를 높이기 위해** 작성되었으며,  
RESTful, Microservice, OpenAPI, OAuth2/OIDC, JWT, RBAC, Secure-coding 등  
**현대 웹 서비스의 핵심 기술**을 실무에 적용 가능한 형태로 정리했습니다.

---

## 📈 향후 확장 계획

### 1단계: 기본 API (완료 ✅)
- 108개 엔드포인트 정의
- 인증/인가, 보안 정책 수립

### 2단계: 엔터프라이즈 표준 (완료 ✅)
- 에러 코드, Pagination, Webhook
- Rate Limiting, SLA/SLO
- HATEOAS, ETag 캐싱

### 3단계: 클라우드 운영 (완료 ✅)
- Health Check, Metrics, Logging
- Microservice 패턴

### 4단계: 향후 계획 (🚧)
- OpenAPI YAML 파일 생성
- Swagger UI 배포
- Postman Collection 생성
- 클라이언트 SDK 자동 생성 (TypeScript, Java, Python)
- GraphQL API 추가 검토

---

**작성자**: 최경민  
**버전**: v1.1.0  
**최종 수정일**: 2024-10-20
