# 시나리오 02: 테이블 작업

## 목차
1. [테이블 생성](#1-테이블-생성)
2. [테이블 실시간 이동](#2-테이블-실시간-이동)
3. [테이블 수정](#3-테이블-수정)
4. [테이블 편집 잠금](#4-테이블-편집-잠금)
5. [테이블 삭제](#5-테이블-삭제)
6. [완전한 작업 플로우](#6-완전한-작업-플로우)

---

## 1. 테이블 생성

### 1-1. REST API로 테이블 생성

**프론트 → 백: POST 요청**
```javascript
async function createTable(projectKey, tableData) {
  const response = await fetch(`/api/v1/erd/projects/${projectKey}/tables`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    credentials: 'include',  // 쿠키 자동 전송
    body: JSON.stringify({
      logicalName: '회원',           // 논리명 (한글)
      physicalName: 'members',       // 물리명 (영문)
      xPosition: 100.0,              // X 좌표
      yPosition: 200.0,              // Y 좌표
      colorHex: 'FF6B6B'             // 색상 (# 없이)
    })
  });

  if (!response.ok) {
    throw new Error('테이블 생성 실패');
  }

  const result = await response.json();
  console.log('테이블 생성 성공:', result);

  // WebSocket 이벤트를 기다림 (자동 브로드캐스트됨)
  return result;
}

// 사용 예시
createTable(123, tableData);
```

**백엔드 처리 순서:**
1. JWT 토큰 검증 (쿠키)
2. 권한 확인 (EDITOR 이상만 생성 가능)
3. PostgreSQL DB에 저장
4. **Kafka에 이벤트 발행**
5. **모든 구독자에게 자동 브로드캐스트** (2초 배치 압축)

### 1-2. WebSocket 이벤트 수신

**백 → 모든 프론트: TableNewEvent**
```javascript
stompClient.subscribe('/topic/project/123', (message) => {
  const event = JSON.parse(message.body);

  if (event.type === 'TableNewEvent') {
    const table = event.event;

    // 캔버스에 새 테이블 추가
    addTableToCanvas({
      id: table.tableKey,
      logicalName: table.logicalName,
      physicalName: table.physicalName,
      x: table.xPosition,
      y: table.yPosition,
      color: '#' + table.colorHex,
      createdAt: table.createdAt
    });

    console.log(`새 테이블 생성됨: ${table.logicalName}`);
  }
});
```

**이벤트 데이터 구조:**
```javascript
{
  "type": "TableNewEvent",
  "projectKey": 123,
  "userKey": 456,
  "event": {
    "tableKey": 10,
    "projectKey": 123,
    "logicalName": "회원",
    "physicalName": "members",
    "xPosition": 100.0,
    "yPosition": 200.0,
    "colorHex": "FF6B6B",
    "createdAt": "2025-01-14T12:00:00Z",
    "updatedAt": "2025-01-14T12:00:00Z"
  }
}
```

**중요 포인트:**
- ✅ REST API 호출한 사용자도 동일한 WebSocket 이벤트를 받습니다.
- ✅ 중복 추가를 방지하려면 `tableKey`로 중복 체크 필요.

```javascript
const existingTables = new Set();

if (event.type === 'TableNewEvent') {
  const tableKey = event.event.tableKey;

  // 중복 체크
  if (existingTables.has(tableKey)) {
    console.log('이미 존재하는 테이블. 무시.');
    return;
  }

  existingTables.add(tableKey);
  addTableToCanvas(event.event);
}
```

---

## 2. 테이블 실시간 이동

### 2-1. 드래그 시작 시

**프론트: 드래그 이벤트 감지**
```javascript
let isDragging = false;
let draggedTableKey = null;

function onTableMouseDown(tableKey, event) {
  isDragging = true;
  draggedTableKey = tableKey;

  console.log(`테이블 ${tableKey} 드래그 시작`);
}
```

### 2-2. 드래그 중 (실시간 위치 전송)

**프론트 → 백: TableMoveEvent 발행**
```javascript
function onTableMouseMove(event) {
  if (!isDragging || !draggedTableKey) return;

  const x = event.clientX;
  const y = event.clientY;

  // WebSocket으로 실시간 위치 전송
  stompClient.send('/pub/erd/table/move', {}, JSON.stringify({
    tableKey: draggedTableKey,
    xPosition: x,
    yPosition: y
  }));
}

// 캔버스에 mousemove 이벤트 등록
canvas.addEventListener('mousemove', onTableMouseMove);
```

**백엔드 처리:**
1. **DB 저장 안함** (휘발성 데이터)
2. **즉시** 모든 구독자에게 브로드캐스트
3. Kafka 미사용
4. 평균 지연시간: **60ms**

### 2-3. 다른 사용자의 드래그 실시간 반영

**백 → 모든 프론트: TableMoveEvent**
```javascript
stompClient.subscribe('/topic/project/123', (message) => {
  const event = JSON.parse(message.body);

  if (event.type === 'TableMoveEvent') {
    const { tableKey, xPosition, yPosition } = event.event;

    // 내가 드래그 중인 테이블이면 무시
    if (tableKey === draggedTableKey && isDragging) {
      return;
    }

    // 다른 사용자가 드래그하는 테이블 실시간 이동
    moveTable(tableKey, xPosition, yPosition);
  }
});

function moveTable(tableKey, x, y) {
  const tableElement = document.querySelector(`[data-table-key="${tableKey}"]`);
  if (tableElement) {
    tableElement.style.left = x + 'px';
    tableElement.style.top = y + 'px';
  }
}
```

### 2-4. 드래그 완료 (최종 위치 저장)

**프론트 → 백: TableMoveEnd 발행**
```javascript
function onTableMouseUp(event) {
  if (!isDragging || !draggedTableKey) return;

  const finalX = event.clientX;
  const finalY = event.clientY;

  // 최종 위치를 DB에 저장
  stompClient.send('/pub/erd/table/move/end', {}, JSON.stringify({
    tableKey: draggedTableKey,
    xPosition: finalX,
    yPosition: finalY
  }));

  console.log(`테이블 ${draggedTableKey} 드래그 완료`);

  // 드래그 상태 초기화
  isDragging = false;
  draggedTableKey = null;
}

// 캔버스에 mouseup 이벤트 등록
canvas.addEventListener('mouseup', onTableMouseUp);
```

**백엔드 처리:**
1. PostgreSQL DB에 **최종 위치만 저장**
2. **브로드캐스트 안함** (응답 없음)
3. Kafka 미사용

**중요 포인트:**
- ✅ 드래그 중(`/pub/erd/table/move`): 실시간 브로드캐스트만, DB 저장 안함
- ✅ 드래그 완료(`/pub/erd/table/move/end`): DB 저장만, 브로드캐스트 안함

---

## 3. 테이블 수정

### 3-1. 논리명/물리명/색상 수정

**프론트 → 백: PATCH 요청**
```javascript
async function updateTable(tableKey, updates) {
  const response = await fetch(`/api/v1/erd/tables/${tableKey}`, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json'
    },
    credentials: 'include',
    body: JSON.stringify({
      logicalName: '사용자',      // 논리명 변경 (선택)
      physicalName: 'users',      // 물리명 변경 (선택)
      colorHex: '4ECDC4'          // 색상 변경 (선택)
    })
  });

  if (!response.ok) {
    throw new Error('테이블 수정 실패');
  }

  return await response.json();
}

// 사용 예시
updateTable(10, {
  logicalName: '사용자',
  physicalName: 'users',
  colorHex: '4ECDC4'
});
```

**백엔드 처리:**
1. PostgreSQL DB 업데이트
2. **변경된 필드별로 개별 이벤트 발행** (Kafka)
   - 논리명 변경 → `TableLnameEvent`
   - 물리명 변경 → `TablePnameEvent`
   - 색상 변경 → `TableColorEvent`

### 3-2. WebSocket 이벤트 수신 (개별 필드)

**논리명 변경 이벤트:**
```javascript
if (event.type === 'TableLnameEvent') {
  const { tableKey, logicalName } = event.event;

  updateTableLogicalName(tableKey, logicalName);
  console.log(`테이블 ${tableKey} 논리명 변경: ${logicalName}`);
}

function updateTableLogicalName(tableKey, logicalName) {
  const tableElement = document.querySelector(`[data-table-key="${tableKey}"]`);
  const nameElement = tableElement.querySelector('.table-logical-name');
  nameElement.textContent = logicalName;
}
```

**물리명 변경 이벤트:**
```javascript
if (event.type === 'TablePnameEvent') {
  const { tableKey, physicalName } = event.event;

  updateTablePhysicalName(tableKey, physicalName);
  console.log(`테이블 ${tableKey} 물리명 변경: ${physicalName}`);
}

function updateTablePhysicalName(tableKey, physicalName) {
  const tableElement = document.querySelector(`[data-table-key="${tableKey}"]`);
  const nameElement = tableElement.querySelector('.table-physical-name');
  nameElement.textContent = physicalName;
}
```

**색상 변경 이벤트:**
```javascript
if (event.type === 'TableColorEvent') {
  const { tableKey, colorHex } = event.event;

  updateTableColor(tableKey, colorHex);
  console.log(`테이블 ${tableKey} 색상 변경: #${colorHex}`);
}

function updateTableColor(tableKey, colorHex) {
  const tableElement = document.querySelector(`[data-table-key="${tableKey}"]`);
  tableElement.style.borderColor = '#' + colorHex;
  tableElement.style.backgroundColor = '#' + colorHex + '20';  // 20% 투명도
}
```

**왜 개별 이벤트로 나뉘나요?**
- 네트워크 효율성: 변경된 필드만 전송
- 이벤트 처리 간소화: 각 이벤트가 명확한 책임
- Batch Compression: 2초 내 동일 테이블의 여러 변경을 압축

---

## 4. 테이블 편집 잠금

### 4-1. 테이블 더블클릭 → 잠금 요청

**프론트 → 백: TableLockEvent 발행**
```javascript
function onTableDoubleClick(tableKey) {
  console.log(`테이블 ${tableKey} 편집 시작 → 잠금 요청`);

  // WebSocket으로 잠금 요청
  stompClient.send('/pub/erd/table/lock', {}, JSON.stringify({
    tableKey: tableKey
  }));
}

// 테이블에 더블클릭 이벤트 등록
tableElement.addEventListener('dblclick', () => {
  onTableDoubleClick(tableKey);
});
```

**백엔드 처리:**
1. Redis에 잠금 저장 (TTL 30초)
2. 이미 잠금이 있으면 **ERROR 이벤트 전송**
3. 성공 시 Kafka 브로드캐스트
4. Heartbeat 10초마다 자동 갱신

### 4-2. 잠금 성공

**백 → 모든 프론트: TableLockEvent**
```javascript
if (event.type === 'TableLockEvent') {
  const { tableKey, userEmail, userName } = event.event;

  // 테이블 잠금 표시
  lockTable(tableKey, userName);

  // 내가 잠근 경우
  if (userEmail === currentUserEmail) {
    showToast('편집 모드로 전환되었습니다.', 'success');
    enableTableEditing(tableKey);
  }
  // 다른 사용자가 잠근 경우
  else {
    showToast(`${userName}님이 편집 중입니다.`, 'info');
    disableTableEditing(tableKey);
  }
}

function lockTable(tableKey, userName) {
  const tableElement = document.querySelector(`[data-table-key="${tableKey}"]`);

  // 잠금 아이콘 표시
  const lockIcon = document.createElement('div');
  lockIcon.className = 'lock-icon';
  lockIcon.innerHTML = `🔒 ${userName}`;
  tableElement.appendChild(lockIcon);

  // 테두리 강조
  tableElement.classList.add('locked');
}
```

### 4-3. 잠금 실패 (다른 사용자가 이미 편집 중)

**백 → 프론트: ERROR 이벤트**
```javascript
if (event.type === 'ERROR') {
  const { code, message, details } = event.data;

  if (code === 'OPERATION_FAILED' && details.reason.includes('편집중')) {
    const lockedBy = details.lockedBy || '다른 사용자';
    showError(`${lockedBy}가 이미 편집 중입니다.`);

    console.log('잠금 실패:', details);
  }
}
```

**에러 데이터 구조:**
```javascript
{
  "type": "ERROR",
  "data": {
    "code": "OPERATION_FAILED",
    "message": "테이블 잠금 획득 실패",
    "details": {
      "reason": "이미 다른 사용자가 편집중입니다.",
      "tableKey": 10,
      "lockedBy": "user@example.com"
    }
  }
}
```

### 4-4. 잠금 Heartbeat (자동 갱신)

**백엔드가 자동 처리:**
- 10초마다 잠금 Heartbeat 전송
- Redis TTL을 30초로 갱신
- 30초 동안 Heartbeat 없으면 자동 해제

**프론트는 별도 처리 불필요:**
```javascript
// ❌ 필요 없음 - 백엔드가 자동 처리
// setInterval(() => {
//   stompClient.send('/pub/erd/table/lock/heartbeat', ...);
// }, 10000);
```

### 4-5. 편집 완료 → 잠금 해제

**프론트 → 백: TableUnlockEvent 발행**
```javascript
function onTableEditComplete(tableKey) {
  console.log(`테이블 ${tableKey} 편집 완료 → 잠금 해제`);

  // WebSocket으로 잠금 해제
  stompClient.send('/pub/erd/table/unlock', {}, JSON.stringify({
    tableKey: tableKey
  }));
}

// 편집 완료 버튼 클릭 시
saveButton.addEventListener('click', () => {
  onTableEditComplete(tableKey);
});
```

**백 → 모든 프론트: TableUnlockEvent**
```javascript
if (event.type === 'TableUnlockEvent') {
  const { tableKey, userEmail } = event.event;

  // 테이블 잠금 해제 표시
  unlockTable(tableKey);

  console.log(`테이블 ${tableKey} 잠금 해제됨`);
}

function unlockTable(tableKey) {
  const tableElement = document.querySelector(`[data-table-key="${tableKey}"]`);

  // 잠금 아이콘 제거
  const lockIcon = tableElement.querySelector('.lock-icon');
  if (lockIcon) {
    lockIcon.remove();
  }

  // 테두리 강조 제거
  tableElement.classList.remove('locked');
}
```

### 4-6. 연결 해제 시 자동 잠금 해제

**사용자가 브라우저를 닫거나 연결이 끊긴 경우:**
- 백엔드의 `SessionDisconnectEvent`가 발동
- 해당 사용자의 **모든 잠금 자동 해제**
- `TableUnlockEvent` 브로드캐스트

**프론트는 별도 처리 불필요:**
```javascript
// ❌ 필요 없음 - 백엔드가 자동 처리
// window.addEventListener('beforeunload', () => {
//   stompClient.send('/pub/erd/table/unlock', ...);
// });
```

---

## 5. 테이블 삭제

### 5-1. REST API로 테이블 삭제

**프론트 → 백: DELETE 요청**
```javascript
async function deleteTable(tableKey) {
  // 확인 대화상자
  if (!confirm('정말 삭제하시겠습니까?')) {
    return;
  }

  const response = await fetch(`/api/v1/erd/tables/${tableKey}`, {
    method: 'DELETE',
    credentials: 'include'
  });

  if (!response.ok) {
    throw new Error('테이블 삭제 실패');
  }

  console.log('테이블 삭제 요청 성공');

  // WebSocket 이벤트를 기다림
  return await response.json();
}

// 삭제 버튼 클릭 시
deleteButton.addEventListener('click', () => {
  deleteTable(tableKey);
});
```

**백엔드 처리:**
1. PostgreSQL에서 **Soft Delete** (deletedAt 컬럼 업데이트)
2. 관련 **컬럼과 관계도 함께 삭제**
3. Kafka 브로드캐스트

### 5-2. WebSocket 이벤트 수신

**백 → 모든 프론트: TableDelEvent**
```javascript
if (event.type === 'TableDelEvent') {
  const { tableKey, deletedAt } = event.event;

  // 캔버스에서 테이블 제거
  removeTableFromCanvas(tableKey);

  console.log(`테이블 ${tableKey} 삭제됨 (${deletedAt})`);
}

function removeTableFromCanvas(tableKey) {
  const tableElement = document.querySelector(`[data-table-key="${tableKey}"]`);

  if (tableElement) {
    // 애니메이션 효과
    tableElement.classList.add('deleting');

    setTimeout(() => {
      tableElement.remove();
    }, 300);  // 300ms 후 제거
  }
}
```

**이벤트 데이터 구조:**
```javascript
{
  "type": "TableDelEvent",
  "projectKey": 123,
  "userKey": 456,
  "event": {
    "tableKey": 10,
    "deletedAt": "2025-01-14T12:05:00Z"
  }
}
```

**중요 포인트:**
- ✅ Soft Delete: DB에서 실제로 삭제되지 않고 `deletedAt` 필드만 업데이트
- ✅ 관련 컬럼/관계 자동 삭제: CASCADE 적용
- ✅ 복구 가능: 관리자 기능으로 복구 가능 (백엔드에서 제공)

---

## 6. 완전한 작업 플로우

### 시나리오: 사용자가 테이블을 생성하고 편집하는 전체 과정

```javascript
// ========== 1. 테이블 생성 ==========
async function createAndEditTable() {
  // 1-1. REST API로 테이블 생성
  const response = await fetch('/api/v1/erd/projects/123/tables', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: JSON.stringify({
      logicalName: '회원',
      physicalName: 'members',
      xPosition: 100,
      yPosition: 200,
      colorHex: 'FF6B6B'
    })
  });

  const result = await response.json();
  const tableKey = result.data.tableKey;

  console.log('테이블 생성 완료:', tableKey);

  // 1-2. WebSocket 이벤트로 테이블이 캔버스에 자동 추가됨
  // (TableNewEvent 핸들러가 처리)

  // ========== 2. 테이블 드래그로 위치 조정 ==========
  // (사용자가 마우스로 드래그)

  // ========== 3. 테이블 편집 시작 (더블클릭) ==========
  await new Promise(resolve => setTimeout(resolve, 1000));  // 1초 대기

  // 3-1. 잠금 요청
  stompClient.send('/pub/erd/table/lock', {}, JSON.stringify({
    tableKey: tableKey
  }));

  // 3-2. 잠금 획득 대기 (TableLockEvent 핸들러가 처리)
  await waitForLock(tableKey);

  console.log('테이블 잠금 획득. 편집 가능.');

  // ========== 4. 테이블 수정 ==========
  await new Promise(resolve => setTimeout(resolve, 2000));  // 2초 편집

  // 4-1. PATCH 요청으로 논리명 변경
  await fetch(`/api/v1/erd/tables/${tableKey}`, {
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: JSON.stringify({
      logicalName: '사용자',
      colorHex: '4ECDC4'
    })
  });

  console.log('테이블 수정 완료');

  // 4-2. WebSocket 이벤트로 변경사항이 자동 반영됨
  // (TableLnameEvent, TableColorEvent 핸들러가 처리)

  // ========== 5. 편집 완료 → 잠금 해제 ==========
  stompClient.send('/pub/erd/table/unlock', {}, JSON.stringify({
    tableKey: tableKey
  }));

  console.log('잠금 해제. 편집 완료.');
}

// 보조 함수: 잠금 획득 대기
function waitForLock(tableKey) {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error('잠금 획득 타임아웃'));
    }, 5000);  // 5초 대기

    const handler = (message) => {
      const event = JSON.parse(message.body);

      if (event.type === 'TableLockEvent' && event.event.tableKey === tableKey) {
        clearTimeout(timeout);
        resolve();
      }

      if (event.type === 'ERROR' && event.data.details?.tableKey === tableKey) {
        clearTimeout(timeout);
        reject(new Error(event.data.message));
      }
    };

    // 임시 구독 (한 번만 실행)
    const subscription = stompClient.subscribe('/topic/project/123', handler);

    // 잠금 획득 후 구독 해제
    setTimeout(() => subscription.unsubscribe(), 6000);
  });
}

// 실행
createAndEditTable();
```

---

## 7. 이벤트 타입 요약

| 이벤트 | 발행 방법 | 특징 | 지연시간 |
|--------|-----------|------|----------|
| **TableNewEvent** | REST API (POST) | DB 저장 + Kafka | 2초 배치 |
| **TableMoveEvent** | WebSocket | 휘발성, 즉시 브로드캐스트 | 60ms |
| **TableMoveEnd** | WebSocket | DB 저장만, 브로드캐스트 없음 | - |
| **TableLnameEvent** | REST API (PATCH) | DB 저장 + Kafka | 2초 배치 |
| **TablePnameEvent** | REST API (PATCH) | DB 저장 + Kafka | 2초 배치 |
| **TableColorEvent** | REST API (PATCH) | DB 저장 + Kafka | 2초 배치 |
| **TableDelEvent** | REST API (DELETE) | DB Soft Delete + Kafka | 2초 배치 |
| **TableLockEvent** | WebSocket | Redis 잠금 + Kafka | 2초 배치 |
| **TableUnlockEvent** | WebSocket | Redis 삭제 + Kafka | 2초 배치 |

---

## 8. 디버깅 체크리스트

### 테이블이 생성 안될 때
- [ ] EDITOR 이상 권한인가?
- [ ] REST API 응답이 200 OK인가?
- [ ] WebSocket이 연결되어 있는가?
- [ ] TableNewEvent 핸들러가 등록되어 있는가?

### 드래그가 안될 때
- [ ] WebSocket이 연결되어 있는가?
- [ ] `/pub/erd/table/move` 엔드포인트가 올바른가?
- [ ] Rate Limit에 걸렸는가? (초당 10개)

### 잠금이 안될 때
- [ ] EDITOR 이상 권한인가?
- [ ] 다른 사용자가 이미 잠금을 획득했는가?
- [ ] ERROR 이벤트가 왔는가?

---

## 9. 참고 문서

- WebSocket 메시지 레퍼런스: `07_WebSocket_메시지_레퍼런스.csv`
- REST API 레퍼런스: `06_API 레퍼런스.csv`
