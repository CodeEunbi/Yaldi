# 시나리오 01: 연결 및 인증

## 목차
1. [WebSocket 연결](#1-websocket-연결)
2. [인증 방식](#2-인증-방식)
3. [멤버 입장/퇴장](#3-멤버-입장퇴장)
4. [권한 체계](#4-권한-체계)
5. [연결 에러 처리](#5-연결-에러-처리)

---

## 1. WebSocket 연결

### 1-1. 연결 엔드포인트

**개발 환경:**
```
ws://localhost:8080/ws
```

**운영 환경:**
```
wss://api.yaldi.kr/ws
```

### 1-2. 프론트엔드 연결 코드

**SockJS + STOMP 사용 (권장):**
```javascript
import SockJS from 'sockjs-client';
import { Stomp } from '@stomp/stompjs';

// 1. SockJS 소켓 생성
const socket = new SockJS('https://api.yaldi.kr/ws');

// 2. STOMP 클라이언트 생성
const stompClient = Stomp.over(socket);

// 3. Heartbeat 설정 (30초)
stompClient.heartbeat = {
  outgoing: 30000,  // 클라이언트 → 서버
  incoming: 30000   // 서버 → 클라이언트
};

// 4. 연결
stompClient.connect({}, onConnect, onError);

function onConnect(frame) {
  console.log('WebSocket 연결 성공:', frame);

  // 5. 프로젝트 토픽 구독
  const projectKey = 123;
  stompClient.subscribe(`/topic/project/${projectKey}`, onMessage);
}

function onMessage(message) {
  const event = JSON.parse(message.body);
  console.log('이벤트 수신:', event);
  handleEvent(event);
}

function onError(error) {
  console.error('WebSocket 연결 실패:', error);
  // 재연결 로직 (Exponential Backoff)
  setTimeout(() => reconnect(), getBackoffDelay());
}
```

---

## 2. 인증 방식

### 2-1. 쿠키 기반 인증 (웹)

**자동 인증 - 별도 헤더 불필요:**
```javascript
// 브라우저가 자동으로 쿠키 전송
// Cookie: accessToken={jwt_token}

const socket = new SockJS('https://api.yaldi.kr/ws');
const stompClient = Stomp.over(socket);

stompClient.connect({}, onConnect, onError);
// ✅ STOMP connect 헤더에 별도 인증 정보 불필요
```

### 2-2. Query Parameter 인증 (모바일)

**모바일 앱에서 쿠키를 사용할 수 없는 경우:**
```javascript
const token = getAccessToken();  // 앱에 저장된 JWT 토큰

const socket = new SockJS(`https://api.yaldi.kr/ws?token=${token}`);
const stompClient = Stomp.over(socket);

stompClient.connect({}, onConnect, onError);
```

### 2-3. 백엔드 인증 처리

**서버 처리 순서:**
1. 쿠키 또는 Query Parameter에서 JWT 토큰 추출
2. JWT 서명 및 만료 시간 검증
3. 사용자의 프로젝트 접근 권한 확인
4. 권한에 따라 WebSocket 세션 생성
   - **OWNER/EDITOR**: 읽기/쓰기 (구독 + 발행)
   - **VIEWER**: 읽기 전용 (구독만)

**인증 실패 시:**
```javascript
// 프론트 수신
{
  "type": "CONNECTION_ERROR",
  "data": {
    "code": 4001,
    "message": "JWT 토큰이 유효하지 않습니다.",
    "closeCode": 4001
  }
}

// WebSocket 연결 자동 종료됨
```

---

## 3. 멤버 입장/퇴장

### 3-1. 연결 성공 시 (CONNECTION_ESTABLISHED)

**프론트 → 백:**
```javascript
// 연결 성공 시 자동으로 첫 메시지 수신
```

**백 → 프론트:**
```javascript
{
  "type": "CONNECTION_ESTABLISHED",
  "data": {
    "sessionId": "sess_abc123",         // WebSocket 세션 ID
    "projectKey": 123,                  // 프로젝트 키
    "userKey": 456,                     // 사용자 키
    "role": "EDITOR",                   // 권한 (OWNER/EDITOR/VIEWER)
    "serverTime": "2025-01-14T12:00:00Z"
  }
}
```

**프론트 처리:**
```javascript
stompClient.subscribe('/topic/project/123', (message) => {
  const event = JSON.parse(message.body);

  if (event.type === 'CONNECTION_ESTABLISHED') {
    console.log('연결 성공! 세션 ID:', event.data.sessionId);
    console.log('내 권한:', event.data.role);

    // 권한에 따라 UI 표시
    if (event.data.role === 'VIEWER') {
      showReadOnlyMode();  // 읽기 전용 모드
    } else {
      showEditMode();      // 편집 모드
    }
  }
});
```

### 3-2. 멤버 입장 (MEMBER_JOIN)

**다른 사용자가 접속했을 때 자동 브로드캐스트:**

**백 → 모든 프론트:**
```javascript
{
  "type": "MEMBER_JOIN",
  "data": {
    "userKey": 789,
    "userEmail": "user3@example.com",
    "userName": "김철수",
    "role": "EDITOR",
    "joinedAt": "2025-01-14T12:05:00Z"
  }
}
```

**프론트 처리:**
```javascript
const onlineUsers = new Map();  // userKey → 사용자 정보

stompClient.subscribe('/topic/project/123', (message) => {
  const event = JSON.parse(message.body);

  if (event.type === 'MEMBER_JOIN') {
    const { userKey, userName, role } = event.data;

    // 온라인 사용자 목록에 추가
    onlineUsers.set(userKey, event.data);

    // 알림 표시
    showNotification(`${userName}님이 입장했습니다.`, 'info');

    // 온라인 사용자 UI 업데이트
    updateOnlineUsersList(Array.from(onlineUsers.values()));
  }
});
```

### 3-3. 멤버 퇴장 (MEMBER_LEAVE)

**사용자가 연결을 끊었을 때 자동 브로드캐스트:**

**백 → 모든 프론트:**
```javascript
{
  "type": "MEMBER_LEAVE",
  "data": {
    "userKey": 789,
    "userEmail": "user3@example.com",
    "userName": "김철수",
    "leftAt": "2025-01-14T12:10:00Z",
    "reason": "DISCONNECTED"  // DISCONNECTED | TIMEOUT | KICKED
  }
}
```

**퇴장 사유:**
- `DISCONNECTED`: 정상 연결 해제 (사용자가 브라우저 닫음 등)
- `TIMEOUT`: 60초 동안 Heartbeat 미응답
- `KICKED`: 관리자가 강제 퇴장

**프론트 처리:**
```javascript
stompClient.subscribe('/topic/project/123', (message) => {
  const event = JSON.parse(message.body);

  if (event.type === 'MEMBER_LEAVE') {
    const { userKey, userName, reason } = event.data;

    // 온라인 사용자 목록에서 제거
    onlineUsers.delete(userKey);

    // 알림 표시
    showNotification(`${userName}님이 퇴장했습니다.`, 'info');

    // 해당 사용자의 커서 제거
    removeCursor(userKey);

    // 해당 사용자가 잠근 테이블 자동 해제됨
    releaseUserLocks(userKey);

    // 온라인 사용자 UI 업데이트
    updateOnlineUsersList(Array.from(onlineUsers.values()));
  }
});
```

**주의사항:**
- 퇴장한 사용자가 잠근 테이블은 **자동으로 해제**됩니다.
- 백엔드에서 `SessionDisconnectEvent`를 통해 자동 처리됩니다.

---

## 4. 권한 체계

### 4-1. 권한 종류

| 권한 | 구독 | 발행 | 설명 |
|------|------|------|------|
| **OWNER** | ✅ | ✅ | 모든 권한 (프로젝트 삭제, 멤버 관리 포함) |
| **EDITOR** | ✅ | ✅ | 읽기/쓰기 (ERD 편집, 버전 생성) |
| **VIEWER** | ✅ | ❌ | 읽기 전용 (구독만 가능, 발행 불가) |

### 4-2. VIEWER 권한 제약

**VIEWER가 발행(send) 시도 시:**

**프론트 → 백:**
```javascript
// VIEWER가 테이블 이동 시도
stompClient.send('/pub/erd/table/move', {}, JSON.stringify({
  tableKey: 10,
  xPosition: 100,
  yPosition: 200
}));
```

**백 → 프론트:**
```javascript
{
  "type": "ERROR",
  "data": {
    "code": "FORBIDDEN",
    "message": "편집 권한이 없습니다. Viewer는 읽기 전용입니다.",
    "details": {
      "role": "VIEWER"
    }
  }
}
```

**프론트 처리:**
```javascript
if (event.type === 'ERROR' && event.data.code === 'FORBIDDEN') {
  showError('편집 권한이 없습니다. 읽기 전용 모드입니다.');

  // UI를 읽기 전용으로 전환
  disableEditMode();
}
```

### 4-3. 권한별 UI 제어

```javascript
let currentUserRole = null;

stompClient.subscribe('/topic/project/123', (message) => {
  const event = JSON.parse(message.body);

  if (event.type === 'CONNECTION_ESTABLISHED') {
    currentUserRole = event.data.role;

    // 권한에 따라 UI 표시
    switch (currentUserRole) {
      case 'OWNER':
        showOwnerUI();  // 삭제, 멤버 관리 버튼 표시
        break;
      case 'EDITOR':
        showEditorUI();  // 편집 버튼 표시
        break;
      case 'VIEWER':
        showViewerUI();  // 모든 편집 버튼 숨김
        break;
    }
  }
});

// 테이블 생성 버튼 클릭 시
function onCreateTableClick() {
  if (currentUserRole === 'VIEWER') {
    showError('편집 권한이 없습니다.');
    return;
  }

  // REST API 호출...
}
```

---

## 5. 연결 에러 처리

### 5-1. 연결 실패 에러 코드

**백 → 프론트:**
```javascript
{
  "type": "CONNECTION_ERROR",
  "data": {
    "code": 4001 | 4003 | 4004 | 4429,
    "message": "에러 메시지",
    "closeCode": 4001  // WebSocket 종료 코드
  }
}
```

**에러 코드:**
- `4001`: **Unauthorized** - JWT 토큰이 유효하지 않음
- `4003`: **Forbidden** - 프로젝트 접근 권한 없음
- `4004`: **Not Found** - 프로젝트가 존재하지 않음
- `4429`: **Too Many Connections** - 동시 접속 24명 초과

### 5-2. 에러 처리 예시

```javascript
function onError(error) {
  console.error('WebSocket 에러:', error);

  // 연결 실패 시 재시도 (Exponential Backoff)
  retryCount++;
  const delay = getBackoffDelay();

  console.log(`${delay}ms 후 재연결 시도...`);
  setTimeout(() => reconnect(), delay);
}

function getBackoffDelay() {
  // 1s → 2s → 4s → 8s → 16s → 최대 30s
  return Math.min(1000 * Math.pow(2, retryCount), 30000);
}

function reconnect() {
  console.log('재연결 시도...');

  const socket = new SockJS('https://api.yaldi.kr/ws');
  const stompClient = Stomp.over(socket);
  stompClient.connect({}, onConnect, onError);
}
```

### 5-3. Heartbeat 타임아웃

**60초 동안 Heartbeat 미응답 시 자동 연결 종료:**

```javascript
stompClient.connect({
  heartbeat: {
    outgoing: 30000,  // 30초마다 Ping 전송
    incoming: 30000   // 30초마다 Pong 수신 대기
  }
}, onConnect, onError);

// 60초(30초 * 2) 동안 응답 없으면 자동 종료됨
```

### 5-4. 네트워크 재연결 감지

```javascript
// 온라인/오프라인 감지
window.addEventListener('online', () => {
  console.log('네트워크 연결됨. WebSocket 재연결 시도...');
  reconnect();
});

window.addEventListener('offline', () => {
  console.log('네트워크 끊김. WebSocket 연결 해제.');
  stompClient.disconnect();
});
```

---

## 6. 연결 상태 관리

### 6-1. 연결 상태 모니터링

```javascript
class WebSocketManager {
  constructor() {
    this.stompClient = null;
    this.isConnected = false;
    this.retryCount = 0;
    this.maxRetries = 10;
  }

  connect(projectKey) {
    const socket = new SockJS('https://api.yaldi.kr/ws');
    this.stompClient = Stomp.over(socket);

    this.stompClient.connect({},
      () => this.onConnect(projectKey),
      (error) => this.onError(error)
    );
  }

  onConnect(projectKey) {
    console.log('WebSocket 연결 성공');
    this.isConnected = true;
    this.retryCount = 0;

    // 상태 UI 업데이트
    updateConnectionStatus('connected');

    // 프로젝트 토픽 구독
    this.stompClient.subscribe(`/topic/project/${projectKey}`, (message) => {
      this.onMessage(message);
    });
  }

  onError(error) {
    console.error('WebSocket 에러:', error);
    this.isConnected = false;

    // 상태 UI 업데이트
    updateConnectionStatus('disconnected');

    // 재시도
    if (this.retryCount < this.maxRetries) {
      const delay = this.getBackoffDelay();
      console.log(`${delay}ms 후 재연결 (${this.retryCount + 1}/${this.maxRetries})`);

      setTimeout(() => this.connect(), delay);
      this.retryCount++;
    } else {
      console.error('최대 재시도 횟수 초과. 연결 포기.');
      showError('서버에 연결할 수 없습니다. 페이지를 새로고침하세요.');
    }
  }

  getBackoffDelay() {
    return Math.min(1000 * Math.pow(2, this.retryCount), 30000);
  }

  disconnect() {
    if (this.stompClient && this.isConnected) {
      this.stompClient.disconnect(() => {
        console.log('WebSocket 연결 해제');
        this.isConnected = false;
      });
    }
  }

  send(destination, data) {
    if (!this.isConnected) {
      console.error('WebSocket 연결 안됨. 메시지 전송 불가.');
      return false;
    }

    this.stompClient.send(destination, {}, JSON.stringify(data));
    return true;
  }

  onMessage(message) {
    const event = JSON.parse(message.body);
    console.log('이벤트 수신:', event.type, event);

    // 이벤트 핸들러로 전달
    eventHandler.handle(event);
  }
}

// 사용 예시
const wsManager = new WebSocketManager();
wsManager.connect(123);  // 프로젝트 123번 연결
```

---

## 7. 디버깅 체크리스트

### 연결이 안될 때

- [ ] 브라우저 개발자 도구 → Network → WS 탭에서 WebSocket 연결 확인
- [ ] 쿠키에 `accessToken`이 있는가?
  ```javascript
  document.cookie.split(';').find(c => c.includes('accessToken'))
  ```
- [ ] JWT 토큰이 유효한가? (만료 확인)
  ```javascript
  // JWT 디코딩 (브라우저 콘솔)
  const token = getCookie('accessToken');
  const payload = JSON.parse(atob(token.split('.')[1]));
  console.log('만료시간:', new Date(payload.exp * 1000));
  ```
- [ ] CORS 에러가 나는가?
  - 허용된 Origin: `http://localhost:5173`, `https://yaldi.kr`
- [ ] 프로젝트 접근 권한이 있는가?

### 이벤트가 안올 때

- [ ] 올바른 토픽을 구독했는가?
  ```javascript
  // ✅ 올바른 예
  stompClient.subscribe('/topic/project/123', callback);

  // ❌ 잘못된 예
  stompClient.subscribe('/topic/project123', callback);  // 슬래시 빠짐
  ```
- [ ] Heartbeat 응답이 오는가?
  - 브라우저 개발자 도구 → Network → WS → Frames 탭 확인
- [ ] 서버가 정상인가?
  ```bash
  curl https://api.yaldi.kr/api/v1/health
  ```

---

## 8. 참고 문서

- WebSocket 메시지 레퍼런스: `07_WebSocket_메시지_레퍼런스.csv`
- 보안 및 인증: `04_보안 및 인증.csv`
