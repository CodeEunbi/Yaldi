# 시나리오 04: 관계 작업

## 목차
1. [관계 생성](#1-관계-생성)
2. [관계 수정](#2-관계-수정)
3. [관계 삭제](#3-관계-삭제)
4. [관계 타입 이해](#4-관계-타입-이해)
5. [참조 동작 이해](#5-참조-동작-이해)

---

## 1. 관계 생성

### 1-1. REST API로 관계 생성

**프론트 → 백: POST 요청**
```javascript
async function createRelation(projectKey, relationData) {
  const response = await fetch(`/api/v1/erd/projects/${projectKey}/relations`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    credentials: 'include',
    body: JSON.stringify({
      fromTableKey: 10,                     // 시작 테이블 (FK 있는 쪽)
      toTableKey: 20,                       // 끝 테이블 (PK 있는 쪽)
      relationType: 'ONE_TO_MANY',          // 관계 타입
      constraintName: 'fk_order_member',    // FK 제약 이름
      onDeleteAction: 'CASCADE',            // 삭제 시 동작
      onUpdateAction: 'NO_ACTION'           // 업데이트 시 동작
    })
  });

  if (!response.ok) {
    throw new Error('관계 생성 실패');
  }

  const result = await response.json();
  console.log('관계 생성 성공:', result);

  return result;
}

// 사용 예시: 주문(orders) → 회원(members) 관계
createRelation(123, {
  fromTableKey: 10,  // orders 테이블
  toTableKey: 20,    // members 테이블
  relationType: 'ONE_TO_MANY',
  constraintName: 'fk_order_member',
  onDeleteAction: 'CASCADE',
  onUpdateAction: 'NO_ACTION'
});
```

**관계 타입:**
- `ONE_TO_ONE`: 1:1 (일대일)
- `ONE_TO_MANY`: 1:N (일대다) - **가장 흔함**
- `MANY_TO_ONE`: N:1 (다대일)
- `MANY_TO_MANY`: N:M (다대다)

### 1-2. WebSocket 이벤트 수신

**백 → 모든 프론트: RelationNewEvent**
```javascript
stompClient.subscribe('/topic/project/123', (message) => {
  const event = JSON.parse(message.body);

  if (event.type === 'RelationNewEvent') {
    const relation = event.event;

    // 캔버스에 관계선 추가
    addRelationToCanvas({
      relationKey: relation.relationKey,
      fromTableKey: relation.fromTableKey,
      toTableKey: relation.toTableKey,
      relationType: relation.relationType,
      constraintName: relation.constraintName,
      onDeleteAction: relation.onDeleteAction,
      onUpdateAction: relation.onUpdateAction
    });

    console.log(`새 관계 생성됨: ${relation.constraintName}`);
  }
});

function addRelationToCanvas(relation) {
  const fromTable = document.querySelector(`[data-table-key="${relation.fromTableKey}"]`);
  const toTable = document.querySelector(`[data-table-key="${relation.toTableKey}"]`);

  if (!fromTable || !toTable) {
    console.error('테이블을 찾을 수 없습니다.');
    return;
  }

  // SVG 라인 생성
  const svg = document.querySelector('#relations-svg');
  const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');

  line.setAttribute('data-relation-key', relation.relationKey);
  line.setAttribute('x1', fromTable.offsetLeft + fromTable.offsetWidth);
  line.setAttribute('y1', fromTable.offsetTop + fromTable.offsetHeight / 2);
  line.setAttribute('x2', toTable.offsetLeft);
  line.setAttribute('y2', toTable.offsetTop + toTable.offsetHeight / 2);
  line.setAttribute('stroke', '#666');
  line.setAttribute('stroke-width', '2');

  // 관계 타입에 따라 스타일 변경
  if (relation.relationType === 'ONE_TO_MANY') {
    line.setAttribute('marker-end', 'url(#arrow-one-to-many)');
  } else if (relation.relationType === 'ONE_TO_ONE') {
    line.setAttribute('marker-end', 'url(#arrow-one-to-one)');
  }

  svg.appendChild(line);
}
```

**이벤트 데이터 구조:**
```javascript
{
  "type": "RelationNewEvent",
  "projectKey": 123,
  "userKey": 456,
  "event": {
    "relationKey": 1,
    "projectKey": 123,
    "fromTableKey": 10,
    "toTableKey": 20,
    "relationType": "ONE_TO_MANY",
    "constraintName": "fk_order_member",
    "onDeleteAction": "CASCADE",
    "onUpdateAction": "NO_ACTION",
    "createdAt": "2025-01-14T12:06:00Z"
  }
}
```

---

## 2. 관계 수정

### 2-1. REST API로 관계 수정

**프론트 → 백: PATCH 요청**
```javascript
async function updateRelation(relationKey, updates) {
  const response = await fetch(`/api/v1/erd/relations/${relationKey}`, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json'
    },
    credentials: 'include',
    body: JSON.stringify({
      relationType: 'MANY_TO_ONE',     // 관계 타입 변경 (선택)
      constraintName: 'fk_posts_users', // 제약 이름 변경 (선택)
      onDeleteAction: 'SET_NULL',      // 삭제 동작 변경 (선택)
      onUpdateAction: 'CASCADE'        // 업데이트 동작 변경 (선택)
    })
  });

  if (!response.ok) {
    throw new Error('관계 수정 실패');
  }

  return await response.json();
}

// 사용 예시
updateRelation(1, {
  relationType: 'MANY_TO_ONE',
  onDeleteAction: 'SET_NULL'
});
```

### 2-2. WebSocket 이벤트 수신

**백 → 모든 프론트: RelationUpdateEvent**
```javascript
if (event.type === 'RelationUpdateEvent') {
  const relation = event.event;

  // 관계 정보 업데이트
  updateRelation(relation.relationKey, {
    relationType: relation.relationType,
    constraintName: relation.constraintName,
    onDeleteAction: relation.onDeleteAction,
    onUpdateAction: relation.onUpdateAction
  });

  console.log(`관계 ${relation.relationKey} 수정됨`);
}

function updateRelation(relationKey, updates) {
  const lineElement = document.querySelector(`[data-relation-key="${relationKey}"]`);

  if (!lineElement) return;

  // 관계 타입에 따라 화살표 변경
  if (updates.relationType === 'ONE_TO_MANY') {
    lineElement.setAttribute('marker-end', 'url(#arrow-one-to-many)');
  } else if (updates.relationType === 'ONE_TO_ONE') {
    lineElement.setAttribute('marker-end', 'url(#arrow-one-to-one)');
  } else if (updates.relationType === 'MANY_TO_MANY') {
    lineElement.setAttribute('marker-end', 'url(#arrow-many-to-many)');
  }

  // 삭제 동작에 따라 색상 변경
  if (updates.onDeleteAction === 'CASCADE') {
    lineElement.setAttribute('stroke', '#ff6b6b');  // 빨간색 (주의)
  } else if (updates.onDeleteAction === 'SET_NULL') {
    lineElement.setAttribute('stroke', '#ffa500');  // 주황색
  } else {
    lineElement.setAttribute('stroke', '#666');     // 기본 회색
  }
}
```

---

## 3. 관계 삭제

### 3-1. REST API로 관계 삭제

**프론트 → 백: DELETE 요청**
```javascript
async function deleteRelation(relationKey) {
  if (!confirm('정말 관계를 삭제하시겠습니까?')) {
    return;
  }

  const response = await fetch(`/api/v1/erd/relations/${relationKey}`, {
    method: 'DELETE',
    credentials: 'include'
  });

  if (!response.ok) {
    throw new Error('관계 삭제 실패');
  }

  console.log('관계 삭제 요청 성공');

  return await response.json();
}

// 삭제 버튼 클릭 시
deleteButton.addEventListener('click', () => {
  deleteRelation(relationKey);
});
```

### 3-2. WebSocket 이벤트 수신

**백 → 모든 프론트: RelationDelEvent**
```javascript
if (event.type === 'RelationDelEvent') {
  const { relationKey } = event.event;

  // 캔버스에서 관계선 제거
  removeRelationFromCanvas(relationKey);

  console.log(`관계 ${relationKey} 삭제됨`);
}

function removeRelationFromCanvas(relationKey) {
  const lineElement = document.querySelector(`[data-relation-key="${relationKey}"]`);

  if (lineElement) {
    // 애니메이션 효과
    lineElement.classList.add('deleting');

    setTimeout(() => {
      lineElement.remove();
    }, 300);  // 300ms 후 제거
  }
}
```

---

## 4. 관계 타입 이해

### 4-1. ONE_TO_ONE (1:1)

**예시: 사용자 ↔ 프로필**
```
users (PK: id)  ←→  profiles (FK: user_id UNIQUE)
```

```javascript
createRelation(projectKey, {
  fromTableKey: profilesTableKey,
  toTableKey: usersTableKey,
  relationType: 'ONE_TO_ONE',
  constraintName: 'fk_profile_user',
  onDeleteAction: 'CASCADE'
});
```

**특징:**
- FK에 UNIQUE 제약 필요
- 한 사용자는 하나의 프로필만
- 프로필 삭제 → 사용자는 유지
- 사용자 삭제 → 프로필도 삭제 (CASCADE)

### 4-2. ONE_TO_MANY (1:N) - 가장 흔함

**예시: 회원 → 주문**
```
members (PK: id)  →  orders (FK: member_id)
```

```javascript
createRelation(projectKey, {
  fromTableKey: ordersTableKey,
  toTableKey: membersTableKey,
  relationType: 'ONE_TO_MANY',
  constraintName: 'fk_order_member',
  onDeleteAction: 'CASCADE'
});
```

**특징:**
- 한 회원은 여러 주문
- 주문 삭제 → 회원은 유지
- 회원 삭제 → 모든 주문 삭제 (CASCADE)

### 4-3. MANY_TO_ONE (N:1)

**예시: 게시글 ← 사용자**
```
posts (FK: user_id)  ←  users (PK: id)
```

```javascript
createRelation(projectKey, {
  fromTableKey: postsTableKey,
  toTableKey: usersTableKey,
  relationType: 'MANY_TO_ONE',
  constraintName: 'fk_post_user',
  onDeleteAction: 'SET_NULL'
});
```

**특징:**
- 여러 게시글이 한 사용자
- ONE_TO_MANY의 반대 방향
- 사용자 삭제 → 게시글의 user_id를 NULL로 (SET_NULL)

### 4-4. MANY_TO_MANY (N:M)

**예시: 학생 ↔ 강의 (중간 테이블 필요)**
```
students (PK: id)  ↔  enrollments (FK: student_id, lecture_id)  ↔  lectures (PK: id)
```

```javascript
// 학생 → 수강신청
createRelation(projectKey, {
  fromTableKey: enrollmentsTableKey,
  toTableKey: studentsTableKey,
  relationType: 'MANY_TO_ONE',
  constraintName: 'fk_enrollment_student',
  onDeleteAction: 'CASCADE'
});

// 강의 → 수강신청
createRelation(projectKey, {
  fromTableKey: enrollmentsTableKey,
  toTableKey: lecturesTableKey,
  relationType: 'MANY_TO_ONE',
  constraintName: 'fk_enrollment_lecture',
  onDeleteAction: 'CASCADE'
});
```

**특징:**
- 중간 테이블(junction table) 필요
- 한 학생은 여러 강의, 한 강의는 여러 학생
- 학생/강의 삭제 → 수강신청 삭제 (CASCADE)

---

## 5. 참조 동작 이해

### 5-1. CASCADE (연쇄 삭제/업데이트)

**예시: 회원 삭제 시 주문도 삭제**
```javascript
{
  onDeleteAction: 'CASCADE',
  onUpdateAction: 'CASCADE'
}
```

**동작:**
- 부모 레코드 삭제 → 자식 레코드도 **자동 삭제**
- 부모 PK 변경 → 자식 FK도 **자동 업데이트**

**주의사항:**
- ⚠️ 데이터 손실 가능 → 신중하게 사용
- ✅ 주문은 회원 없이 존재할 수 없는 경우 적합

### 5-2. SET_NULL (NULL로 설정)

**예시: 작성자 삭제 시 게시글은 유지 (작성자 NULL)**
```javascript
{
  onDeleteAction: 'SET_NULL',
  onUpdateAction: 'SET_NULL'
}
```

**동작:**
- 부모 레코드 삭제 → 자식 FK를 **NULL로 설정**
- 부모 PK 변경 → 자식 FK를 **NULL로 설정**

**주의사항:**
- ⚠️ FK 컬럼이 `NULLABLE`이어야 함
- ✅ 게시글은 작성자 없이 존재 가능한 경우 적합

### 5-3. SET_DEFAULT (기본값으로 설정)

**예시: 카테고리 삭제 시 "미분류" 카테고리로 변경**
```javascript
{
  onDeleteAction: 'SET_DEFAULT',
  onUpdateAction: 'SET_DEFAULT'
}
```

**동작:**
- 부모 레코드 삭제 → 자식 FK를 **기본값으로 설정**
- 부모 PK 변경 → 자식 FK를 **기본값으로 설정**

**주의사항:**
- ⚠️ FK 컬럼에 `DEFAULT` 값이 정의되어 있어야 함
- ✅ "미분류" 같은 기본 카테고리가 있는 경우 적합

### 5-4. RESTRICT (삭제/업데이트 차단)

**예시: 주문이 있는 회원은 삭제 불가**
```javascript
{
  onDeleteAction: 'RESTRICT',
  onUpdateAction: 'RESTRICT'
}
```

**동작:**
- 부모 레코드 삭제 → 자식이 있으면 **에러 발생** (삭제 차단)
- 부모 PK 변경 → 자식이 있으면 **에러 발생** (업데이트 차단)

**주의사항:**
- ✅ 데이터 무결성 보장
- ⚠️ 부모 삭제 전 자식을 먼저 삭제해야 함

### 5-5. NO_ACTION (아무 작업 안함)

**예시: 기본 동작**
```javascript
{
  onDeleteAction: 'NO_ACTION',
  onUpdateAction: 'NO_ACTION'
}
```

**동작:**
- 부모 레코드 삭제/업데이트 시 **아무 작업 안함**
- RESTRICT와 유사하지만 제약 검사 시점이 다름

**주의사항:**
- PostgreSQL에서는 RESTRICT와 동일하게 동작
- MySQL에서는 완전히 무시 (권장 안함)

---

## 6. 완전한 작업 플로우

### 시나리오: 블로그 ERD 구성

```javascript
async function createBlogERD() {
  const projectKey = 123;

  // ========== 1. 테이블 생성 ==========
  // 사용자 테이블
  const usersRes = await fetch(`/api/v1/erd/projects/${projectKey}/tables`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: JSON.stringify({
      logicalName: '사용자',
      physicalName: 'users',
      xPosition: 100,
      yPosition: 100,
      colorHex: 'FF6B6B'
    })
  });
  const users = (await usersRes.json()).data;

  // 게시글 테이블
  const postsRes = await fetch(`/api/v1/erd/projects/${projectKey}/tables`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: JSON.stringify({
      logicalName: '게시글',
      physicalName: 'posts',
      xPosition: 400,
      yPosition: 100,
      colorHex: '4ECDC4'
    })
  });
  const posts = (await postsRes.json()).data;

  // 댓글 테이블
  const commentsRes = await fetch(`/api/v1/erd/projects/${projectKey}/tables`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: JSON.stringify({
      logicalName: '댓글',
      physicalName: 'comments',
      xPosition: 700,
      yPosition: 100,
      colorHex: 'FFD93D'
    })
  });
  const comments = (await commentsRes.json()).data;

  // ========== 2. 관계 생성 ==========
  // 사용자 → 게시글 (1:N)
  await fetch(`/api/v1/erd/projects/${projectKey}/relations`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: JSON.stringify({
      fromTableKey: posts.tableKey,
      toTableKey: users.tableKey,
      relationType: 'MANY_TO_ONE',
      constraintName: 'fk_post_user',
      onDeleteAction: 'SET_NULL',  // 사용자 삭제 시 게시글 유지
      onUpdateAction: 'CASCADE'
    })
  });

  // 게시글 → 댓글 (1:N)
  await fetch(`/api/v1/erd/projects/${projectKey}/relations`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: JSON.stringify({
      fromTableKey: comments.tableKey,
      toTableKey: posts.tableKey,
      relationType: 'MANY_TO_ONE',
      constraintName: 'fk_comment_post',
      onDeleteAction: 'CASCADE',  // 게시글 삭제 시 댓글도 삭제
      onUpdateAction: 'CASCADE'
    })
  });

  // 사용자 → 댓글 (1:N)
  await fetch(`/api/v1/erd/projects/${projectKey}/relations`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: JSON.stringify({
      fromTableKey: comments.tableKey,
      toTableKey: users.tableKey,
      relationType: 'MANY_TO_ONE',
      constraintName: 'fk_comment_user',
      onDeleteAction: 'SET_NULL',  // 사용자 삭제 시 댓글 유지
      onUpdateAction: 'CASCADE'
    })
  });

  console.log('블로그 ERD 구성 완료!');
}

// 실행
createBlogERD();
```

**결과 ERD:**
```
users (사용자)
  ↓ (1:N, SET_NULL)
posts (게시글)
  ↓ (1:N, CASCADE)
comments (댓글)
  ↓ (N:1, SET_NULL)
users (사용자)
```

---

## 7. 이벤트 타입 요약

| 이벤트 | 발행 방법 | 특징 | 지연시간 |
|--------|-----------|------|----------|
| **RelationNewEvent** | REST API (POST) | DB 저장 + Kafka | 2초 배치 |
| **RelationUpdateEvent** | REST API (PATCH) | DB 저장 + Kafka | 2초 배치 |
| **RelationDelEvent** | REST API (DELETE) | DB Soft Delete + Kafka | 2초 배치 |

---

## 8. 디버깅 체크리스트

### 관계가 생성 안될 때
- [ ] EDITOR 이상 권한인가?
- [ ] fromTableKey와 toTableKey가 올바른가?
- [ ] 두 테이블 모두 존재하는가?
- [ ] relationType이 유효한 값인가?

### 관계선이 화면에 안보일 때
- [ ] RelationNewEvent 핸들러가 등록되어 있는가?
- [ ] SVG 요소가 올바르게 생성되었는가?
- [ ] 테이블 위치가 겹쳐서 안보이는가?

### CASCADE가 작동 안할 때
- [ ] onDeleteAction이 'CASCADE'로 설정되어 있는가?
- [ ] DB에 FK 제약이 실제로 생성되었는가?
- [ ] Soft Delete를 사용하는가? (deletedAt 확인)

---

## 9. 참고 문서

- WebSocket 메시지 레퍼런스: `07_WebSocket_메시지_레퍼런스.csv`
- REST API 레퍼런스: `06_API 레퍼런스.csv`
