# 시나리오 06: 이벤트 타입 레퍼런스

## 목차
1. [이벤트 타입 분류](#1-이벤트-타입-분류)
2. [A 타입: REST + Kafka](#2-a-타입-rest--kafka)
3. [B 타입: WebSocket + Kafka](#3-b-타입-websocket--kafka)
4. [C 타입: WebSocket + Redis + Kafka](#4-c-타입-websocket--redis--kafka)
5. [D 타입: Direct Broadcast](#5-d-타입-direct-broadcast)
6. [자동 이벤트](#6-자동-이벤트)
7. [빠른 참조 테이블](#7-빠른-참조-테이블)

---

## 1. 이벤트 타입 분류

### 1-1. 타입별 특징 비교

| 타입 | 발행 방법 | DB 저장 | Kafka | 지연시간 | 휘발성 | 개수 |
|------|-----------|---------|-------|----------|--------|------|
| **A** | REST API | ✅ PostgreSQL | ✅ | ~2초 | ❌ | 11개 |
| **A-1** | WebSocket | ❌ | ❌ | ~60ms | ✅ | 1개 |
| **A-2** | WebSocket | ✅ PostgreSQL | ❌ | - | ❌ | 1개 |
| **B** | WebSocket | ✅ PostgreSQL | ✅ | ~2초 | ❌ | 1개 |
| **C** | WebSocket | ✅ Redis | ✅ | ~2초 | ❌ | 2개 |
| **D** | WebSocket | ❌ | ❌ | ~60ms | ✅✅ | 1개 |
| **자동** | 서버 | - | - | 즉시 | - | 3개 |

### 1-2. 휘발성 vs 영속성

**휘발성 (Volatile):**
- DB/Redis에 저장 안함
- 서버 재시작 시 사라짐
- 실시간성이 중요한 데이터
- 예: 커서 위치, 드래그 중 위치

**영속성 (Persistent):**
- DB/Redis에 저장됨
- 서버 재시작 후에도 유지
- 데이터 무결성이 중요
- 예: 테이블/컬럼/관계 데이터

---

## 2. A 타입: REST + Kafka

### 2-1. 특징

- **발행 방법**: REST API 호출 시 자동 브로드캐스트
- **DB 저장**: PostgreSQL
- **Kafka 사용**: ✅ (Batch Compression 적용, 2초 간격)
- **지연시간**: ~2초
- **휘발성**: ❌ (영속)

### 2-2. 이벤트 목록 (11개)

#### 테이블 (5개)

**1. TableNewEvent - 테이블 생성**
```javascript
// 프론트 → 백: REST API
POST /api/v1/erd/projects/{projectKey}/tables

// 백 → 프론트: WebSocket
{
  "type": "TableNewEvent",
  "event": {
    "tableKey": 10,
    "logicalName": "회원",
    "physicalName": "members",
    "xPosition": 100.0,
    "yPosition": 200.0,
    "colorHex": "FF6B6B",
    "createdAt": "2025-01-14T12:00:00Z"
  }
}
```

**2. TableLnameEvent - 테이블 논리명 변경**
```javascript
// 프론트 → 백: REST API
PATCH /api/v1/erd/tables/{tableKey}
{ "logicalName": "사용자" }

// 백 → 프론트: WebSocket
{
  "type": "TableLnameEvent",
  "event": {
    "tableKey": 10,
    "logicalName": "사용자"
  }
}
```

**3. TablePnameEvent - 테이블 물리명 변경**
```javascript
// 프론트 → 백: REST API
PATCH /api/v1/erd/tables/{tableKey}
{ "physicalName": "users" }

// 백 → 프론트: WebSocket
{
  "type": "TablePnameEvent",
  "event": {
    "tableKey": 10,
    "physicalName": "users"
  }
}
```

**4. TableColorEvent - 테이블 색상 변경**
```javascript
// 프론트 → 백: REST API
PATCH /api/v1/erd/tables/{tableKey}
{ "colorHex": "4ECDC4" }

// 백 → 프론트: WebSocket
{
  "type": "TableColorEvent",
  "event": {
    "tableKey": 10,
    "colorHex": "4ECDC4"
  }
}
```

**5. TableDelEvent - 테이블 삭제**
```javascript
// 프론트 → 백: REST API
DELETE /api/v1/erd/tables/{tableKey}

// 백 → 프론트: WebSocket
{
  "type": "TableDelEvent",
  "event": {
    "tableKey": 10,
    "deletedAt": "2025-01-14T12:05:00Z"
  }
}
```

#### 컬럼 (3개)

**6. ColumnNewEvent - 컬럼 생성**
```javascript
// 프론트 → 백: REST API
POST /api/v1/erd/tables/{tableKey}/columns

// 백 → 프론트: WebSocket
{
  "type": "ColumnNewEvent",
  "event": {
    "columnKey": 101,
    "tableKey": 10,
    "logicalName": "회원 아이디",
    "physicalName": "member_id",
    "dataType": "BIGINT",
    "isPrimaryKey": true,
    "columnOrder": 1
  }
}
```

**7. ColumnUpdateEvent - 컬럼 수정**
```javascript
// 프론트 → 백: REST API
PATCH /api/v1/erd/columns/{columnKey}

// 백 → 프론트: WebSocket
{
  "type": "ColumnUpdateEvent",
  "event": {
    "columnKey": 101,
    "logicalName": "사용자 이메일",
    "dataType": "VARCHAR",
    "dataDetail": ["255"]
  }
}
```

**8. ColumnDelEvent - 컬럼 삭제**
```javascript
// 프론트 → 백: REST API
DELETE /api/v1/erd/columns/{columnKey}

// 백 → 프론트: WebSocket
{
  "type": "ColumnDelEvent",
  "event": {
    "columnKey": 101,
    "deletedAt": "2025-01-14T12:05:00Z"
  }
}
```

#### 관계 (3개)

**9. RelationNewEvent - 관계 생성**
```javascript
// 프론트 → 백: REST API
POST /api/v1/erd/projects/{projectKey}/relations

// 백 → 프론트: WebSocket
{
  "type": "RelationNewEvent",
  "event": {
    "relationKey": 1,
    "fromTableKey": 10,
    "toTableKey": 20,
    "relationType": "ONE_TO_MANY",
    "onDeleteAction": "CASCADE"
  }
}
```

**10. RelationUpdateEvent - 관계 수정**
```javascript
// 프론트 → 백: REST API
PATCH /api/v1/erd/relations/{relationKey}

// 백 → 프론트: WebSocket
{
  "type": "RelationUpdateEvent",
  "event": {
    "relationKey": 1,
    "relationType": "MANY_TO_ONE",
    "onDeleteAction": "SET_NULL"
  }
}
```

**11. RelationDelEvent - 관계 삭제**
```javascript
// 프론트 → 백: REST API
DELETE /api/v1/erd/relations/{relationKey}

// 백 → 프론트: WebSocket
{
  "type": "RelationDelEvent",
  "event": {
    "relationKey": 1,
    "deletedAt": "2025-01-14T12:08:00Z"
  }
}
```

---

## 3. B 타입: WebSocket + Kafka

### 3-1. 특징

- **발행 방법**: WebSocket으로 발행
- **DB 저장**: PostgreSQL
- **Kafka 사용**: ✅ (Batch Compression 적용)
- **지연시간**: ~2초
- **휘발성**: ❌ (영속)

### 3-2. 이벤트 목록 (1개)

**ColumnOrderEvent - 컬럼 순서 변경**
```javascript
// 프론트 → 백: WebSocket
stompClient.send('/pub/erd/column/reorder', {}, JSON.stringify({
  columnKey: 101,
  columnOrder: 2
}));

// 백 → 프론트: WebSocket
{
  "type": "ColumnOrderEvent",
  "event": {
    "columnKey": 101,
    "columnOrder": 2
  }
}
```

**사용 사례:**
- 드래그 앤 드롭으로 컬럼 순서 변경
- DB 업데이트 후 Kafka 브로드캐스트

---

## 4. C 타입: WebSocket + Redis + Kafka

### 4-1. 특징

- **발행 방법**: WebSocket으로 발행
- **저장소**: Redis (잠금 정보, TTL 30초)
- **Kafka 사용**: ✅
- **지연시간**: ~2초
- **휘발성**: ❌ (Redis에 30초간 유지)
- **자동 해제**: 연결 해제 시 자동 잠금 해제

### 4-2. 이벤트 목록 (2개)

**1. TableLockEvent - 테이블 편집 잠금**
```javascript
// 프론트 → 백: WebSocket
stompClient.send('/pub/erd/table/lock', {}, JSON.stringify({
  tableKey: 10
}));

// 백 → 프론트: WebSocket (성공 시)
{
  "type": "TableLockEvent",
  "event": {
    "tableKey": 10,
    "userEmail": "user@example.com",
    "userName": "홍길동"
  }
}

// 백 → 프론트: WebSocket (실패 시)
{
  "type": "ERROR",
  "data": {
    "code": "OPERATION_FAILED",
    "message": "테이블 잠금 획득 실패",
    "details": {
      "tableKey": 10,
      "lockedBy": "other@example.com"
    }
  }
}
```

**Redis 저장 구조:**
```
key: table:lock:10
value: { "userKey": 456, "userEmail": "user@example.com" }
TTL: 30초
```

**Heartbeat:**
- 10초마다 TTL 갱신
- 30초 동안 Heartbeat 없으면 자동 해제

**2. TableUnlockEvent - 테이블 편집 잠금 해제**
```javascript
// 프론트 → 백: WebSocket
stompClient.send('/pub/erd/table/unlock', {}, JSON.stringify({
  tableKey: 10
}));

// 백 → 프론트: WebSocket
{
  "type": "TableUnlockEvent",
  "event": {
    "tableKey": 10,
    "userEmail": "user@example.com"
  }
}
```

**자동 해제 시나리오:**
- 사용자가 브라우저를 닫음
- 네트워크 연결 끊김
- WebSocket 연결 해제
- → `SessionDisconnectEvent` 발동
- → 해당 사용자의 모든 잠금 자동 해제
- → `TableUnlockEvent` 브로드캐스트

---

## 5. D 타입: Direct Broadcast

### 5-1. 특징

- **발행 방법**: WebSocket으로 발행
- **DB 저장**: ❌ (완전 휘발성)
- **Redis 저장**: ❌
- **Kafka 사용**: ❌
- **지연시간**: ~60ms (가장 빠름)
- **휘발성**: ✅✅ (완전 휘발성)

### 5-2. 이벤트 목록 (1개)

**CursorPosEvent - 커서 위치 공유**
```javascript
// 프론트 → 백: WebSocket
stompClient.send('/pub/erd/cursor', {}, JSON.stringify({
  projectKey: 123,
  xPosition: 350.5,
  yPosition: 420.8
}));

// 백 → 프론트: WebSocket (즉시)
{
  "type": "CursorPosEvent",
  "event": {
    "projectKey": 123,
    "userEmail": "user@example.com",
    "userName": "홍길동",
    "userColor": "#ff6b6b",  // 이메일 해시 기반 자동 생성
    "xPosition": 350.5,
    "yPosition": 420.8
  }
}
```

**사용 권장사항:**
- Throttling 필수: 50-100ms
- 초당 최대 30회 전송 권장
- 완전 휘발성: 서버 재시작 시 사라짐

---

## 6. 자동 이벤트

### 6-1. 특징

- **발행 방법**: 서버가 자동 발행
- **사용자 액션**: 불필요
- **지연시간**: 즉시

### 6-2. 이벤트 목록 (3개)

**1. CONNECTION_ESTABLISHED - WebSocket 연결 성공**
```javascript
// 서버 → 프론트: 자동 (연결 직후)
{
  "type": "CONNECTION_ESTABLISHED",
  "data": {
    "sessionId": "sess_abc123",
    "projectKey": 123,
    "userKey": 456,
    "role": "EDITOR",
    "serverTime": "2025-01-14T12:00:00Z"
  }
}
```

**2. MEMBER_JOIN - 멤버 입장**
```javascript
// 서버 → 모든 프론트: 자동 (새 사용자 접속 시)
{
  "type": "MEMBER_JOIN",
  "data": {
    "userKey": 789,
    "userEmail": "user3@example.com",
    "userName": "김철수",
    "role": "EDITOR",
    "joinedAt": "2025-01-14T12:05:00Z"
  }
}
```

**3. MEMBER_LEAVE - 멤버 퇴장**
```javascript
// 서버 → 모든 프론트: 자동 (사용자 연결 해제 시)
{
  "type": "MEMBER_LEAVE",
  "data": {
    "userKey": 789,
    "userEmail": "user3@example.com",
    "userName": "김철수",
    "leftAt": "2025-01-14T12:10:00Z",
    "reason": "DISCONNECTED"  // DISCONNECTED | TIMEOUT | KICKED
  }
}
```

---

## 7. 빠른 참조 테이블

### 7-1. 전체 이벤트 목록

| # | 이벤트 | 타입 | 발행 방법 | 지연 | 휘발성 |
|---|--------|------|-----------|------|--------|
| 1 | `TableNewEvent` | A | REST API | 2초 | ❌ |
| 2 | `TableLnameEvent` | A | REST API | 2초 | ❌ |
| 3 | `TablePnameEvent` | A | REST API | 2초 | ❌ |
| 4 | `TableColorEvent` | A | REST API | 2초 | ❌ |
| 5 | `TableDelEvent` | A | REST API | 2초 | ❌ |
| 6 | `TableMoveEvent` | A-1 | WebSocket | 60ms | ✅ |
| 7 | `TableMoveEnd` | A-2 | WebSocket | - | ❌ |
| 8 | `TableLockEvent` | C | WebSocket | 2초 | ❌ |
| 9 | `TableUnlockEvent` | C | WebSocket | 2초 | ❌ |
| 10 | `ColumnNewEvent` | A | REST API | 2초 | ❌ |
| 11 | `ColumnUpdateEvent` | A | REST API | 2초 | ❌ |
| 12 | `ColumnOrderEvent` | B | WebSocket | 2초 | ❌ |
| 13 | `ColumnDelEvent` | A | REST API | 2초 | ❌ |
| 14 | `RelationNewEvent` | A | REST API | 2초 | ❌ |
| 15 | `RelationUpdateEvent` | A | REST API | 2초 | ❌ |
| 16 | `RelationDelEvent` | A | REST API | 2초 | ❌ |
| 17 | `CursorPosEvent` | D | WebSocket | 60ms | ✅✅ |
| 18 | `CONNECTION_ESTABLISHED` | 자동 | 서버 | 즉시 | - |
| 19 | `MEMBER_JOIN` | 자동 | 서버 | 즉시 | - |
| 20 | `MEMBER_LEAVE` | 자동 | 서버 | 즉시 | - |
| 21 | `ERROR` | 자동 | 서버 | 즉시 | - |

**총 21개 이벤트**

### 7-2. 타입별 이벤트 개수

| 타입 | 개수 | 이벤트 |
|------|------|--------|
| **A** | 11개 | Table(5), Column(3), Relation(3) |
| **A-1** | 1개 | TableMoveEvent |
| **A-2** | 1개 | TableMoveEnd |
| **B** | 1개 | ColumnOrderEvent |
| **C** | 2개 | TableLockEvent, TableUnlockEvent |
| **D** | 1개 | CursorPosEvent |
| **자동** | 4개 | CONNECTION_ESTABLISHED, MEMBER_JOIN, MEMBER_LEAVE, ERROR |

### 7-3. 발행 엔드포인트

| 엔드포인트 | 이벤트 |
|-----------|--------|
| `/pub/erd/table/move` | TableMoveEvent |
| `/pub/erd/table/move/end` | TableMoveEnd |
| `/pub/erd/table/lock` | TableLockEvent |
| `/pub/erd/table/unlock` | TableUnlockEvent |
| `/pub/erd/column/reorder` | ColumnOrderEvent |
| `/pub/erd/cursor` | CursorPosEvent |

### 7-4. 구독 엔드포인트

**모든 이벤트:**
```
/topic/project/{projectKey}
```

---

## 8. 이벤트 선택 가이드

### 8-1. 실시간성이 중요한 경우

**사용 타입: D (Direct Broadcast)**
- 지연시간: 60ms
- 예: 커서 위치, 드래그 중 위치

### 8-2. 데이터 무결성이 중요한 경우

**사용 타입: A (REST + Kafka)**
- DB 저장: PostgreSQL
- 예: 테이블/컬럼/관계 생성/수정/삭제

### 8-3. 일시적인 상태 관리

**사용 타입: C (WebSocket + Redis + Kafka)**
- Redis 저장 (TTL)
- 예: 편집 잠금 (30초 TTL)

### 8-4. WebSocket으로 빠르게 저장

**사용 타입: B (WebSocket + Kafka)**
- WebSocket 발행 + DB 저장
- 예: 컬럼 순서 변경 (드래그 앤 드롭)

---

## 9. 성능 비교

| 타입 | 지연시간 | Throughput | 사용 사례 |
|------|----------|------------|-----------|
| **D** | ~60ms | 높음 | 커서, 드래그 중 |
| **A-1** | ~60ms | 높음 | 테이블 드래그 중 |
| **A-2** | - | - | 최종 위치 저장 |
| **C** | ~2초 | 중간 | 편집 잠금 |
| **B** | ~2초 | 중간 | 컬럼 순서 변경 |
| **A** | ~2초 | 중간 | CRUD 작업 |

**Batch Compression:**
- 2초 간격으로 Kafka 이벤트 배치 처리
- 동일 테이블/컬럼의 연속 변경을 하나로 압축

---

## 10. 참고 문서

- WebSocket 메시지 레퍼런스: `07_WebSocket_메시지_레퍼런스.csv`
- REST API 레퍼런스: `06_API 레퍼런스.csv`
