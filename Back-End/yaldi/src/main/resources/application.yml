server:
  port: ${SERVER_PORT:8080}

spring:
  config:
    import: optional:file:.env[.properties]
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:-dev}
  datasource:
    url: jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
    driver-class-name: org.postgresql.Driver
    hikari:
      pool-name: YaldiHikariPool
      minimum-idle: 5
      maximum-pool-size: 20
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
      auto-commit: true
      connection-test-query: SELECT 1
      leak-detection-threshold: 60000
      register-mbeans: true
      data-source-properties:
        cachePrepStmts: true
        prepStmtCacheSize: 250
        prepStmtCacheSqlLimit: 2048
  jpa:
    hibernate:
      ddl-auto: none
    show-sql: false
    database: postgresql
    database-platform: org.hibernate.dialect.PostgreSQLDialect
    open-in-view: false
    properties:
      hibernate:
        jdbc:
          time_zone: UTC
        temp:
          use_jdbc_metadata_defaults: false
        type:
          preferred_java_type_jdbc_type_code_mappings: true
  flyway:
    enabled: true
    locations: classpath:db/migration
    sql-migration-prefix: V
    sql-migration-separator: __
    sql-migration-suffixes: .sql
    validate-on-migrate: true # 얘가 말썽쟁이임, 버전 체크하는 애
    clean-disabled: true

  jackson:
    # JSON 응답에 null 값을 포함하도록 설정
    default-property-inclusion: always  # null 값도 JSON에 포함
    serialization:
      write-null-map-values: true  # Map의 null 값도 직렬화
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:redis}
      timeout: 3000ms
      lettuce:
        pool:
          min-idle: 2
          max-idle: 8
          max-active: 8
          max-wait: -1ms
  elasticsearch:
    uris: ${ELASTICSEARCH_URI:http://localhost:9200}
    connection-timeout: 10s
    socket-timeout: 60s
  mail:
    host: ${MAIL_HOST:smtp.gmail.com}
    port: ${MAIL_PORT:587}
    username: ${MAIL_USERNAME}
    password: ${MAIL_PASSWORD}
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
            required: true
          connectiontimeout: 10000
          timeout: 10000
          writetimeout: 10000


  kafka:
    bootstrap-servers: ${KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
    consumer:
      group-id: ${KAFKA_CONSUMER_GROUP_ID:yaldi-consumer-group}
      auto-offset-reset: earliest
      enable-auto-commit: false
    producer:
      acks: all
      retries: 3
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: ${GOOGLE_CLIENT_ID}
            client-secret: ${GOOGLE_CLIENT_SECRET}
            redirect-uri: ${GOOGLE_REDIRECT_URI:http://localhost:8080/login/oauth2/code/google}
            # IMPORTANT: 'openid' scope는 반드시 필요 - 이게 있어야 OIDC 방식으로 처리됨 (CustomOidcUserService)
            # 'openid' scope가 없으면 일반 OAuth2로 처리되어 CustomOAuth2UserService로 라우팅되어 에러 발생
            scope:
              - openid  # 필수! Google OIDC 인증을 위해 필요
              - email
              - profile
          github:
            client-id: ${GITHUB_CLIENT_ID}
            client-secret: ${GITHUB_CLIENT_SECRET}
            redirect-uri: ${GITHUB_REDIRECT_URI:http://localhost:8080/login/oauth2/code/github}
            scope:
              - read:user
              - user:email
        provider:
          google:
            authorization-uri: https://accounts.google.com/o/oauth2/v2/auth
            token-uri: https://oauth2.googleapis.com/token
            user-info-uri: https://www.googleapis.com/oauth2/v3/userinfo
            user-name-attribute: sub
          github:
            authorization-uri: https://github.com/login/oauth/authorize
            token-uri: https://github.com/login/oauth/access_token
            user-info-uri: https://api.github.com/user
            user-name-attribute: id

springdoc:
  swagger-ui:
    path: /swagger
    operations-sorter: alpha
    tags-sorter: alpha
    url: /api-docs
    disable-swagger-default-url: true
  api-docs:
    path: /api-docs
  default-consumes-media-type: application/json
  default-produces-media-type: application/json

jwt:
  secret: ${JWT_SECRET}
  access-token-expiration: ${JWT_ACCESS_TOKEN_EXPIRATION:3600000}  # 1시간 (밀리초)
  refresh-token-expiration: ${JWT_REFRESH_TOKEN_EXPIRATION:604800000}  # 7일 (밀리초)

oauth2:
  authorized-redirect-uris: ${OAUTH2_REDIRECT_URIS:http://localhost:5173/oauth2/redirect}

cors:
  allowed-origins:
    - http://localhost:5173
    - http://localhost:3000
    - https://yaldi.kr

cookie:
  secure: false
  same-site: Lax
  domain:  # 빈 값: domain 설정 안함 (요청한 호스트가 자동으로 사용됨)

# AWS S3 설정
aws:
  access:
    key: ${AWS_ACCESS_KEY}
  secret:
    key: ${AWS_SECRET_KEY}
  s3:
    bucket:
      name: ${AWS_S3_BUCKET_NAME}
    region: ${AWS_S3_REGION:ap-northeast-2}

# AI Server 설정
ai:
  server:
    url: ${AI_SERVER_URL:http://localhost:8000}
    timeout: 300000  # 5분

# Frontend URL 설정
frontend:
  url: ${FRONTEND_URL:http://localhost:5173}

logging:
  level:
    root: INFO
#    org.springframework.messaging: DEBUG
#    org.springframework.web.socket: DEBUG
#    com.zaxxer.hikari: INFO
#    org.hibernate.engine.jdbc.env.internal.LobCreatorBuilderImpl: WARN
#    org.hibernate.orm.connections.pooling: INFO

# Actuator & Prometheus
management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus,metrics
      base-path: /actuator
  endpoint:
    health:
      show-details: always
  metrics:
    tags:
      application: ${spring.application.name:yaldi}
